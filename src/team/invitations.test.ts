import { load } from './load'
import { Team } from './Team'
import { DeviceType, DeviceWithSecrets, getDeviceId, redactDevice } from '/device'
import { acceptDeviceInvitation, acceptMemberInvitation, ProofOfInvitation } from '/invitation'
import * as keyset from '/keyset'
import { KeyType } from '/keyset'
import { ADMIN } from '/role'
import { redactUser } from '/user'
import {
  alicesContext,
  bob,
  bobsContext,
  charlie,
  defaultContext,
  eve,
  newTeam,
} from '/util/testing'

const { DEVICE } = KeyType

describe('Team', () => {
  const setup = () => ({
    team: newTeam(),
    context: defaultContext,
  })

  describe('invitations', () => {
    describe('members', () => {
      it('creates an invitation', () => {
        const { team } = setup()

        // üë©üèæ Alice invites üë®‚Äçü¶≤ Bob
        const { secretKey } = team.inviteMember('bob')
        expect(secretKey).toHaveLength(16)
      })

      it('accepts valid proof of invitation', () => {
        const { team: alicesTeam } = setup()

        // üë©üèæ Alice invites üë®‚Äçü¶≤ Bob by sending him a random secret key
        const { secretKey } = alicesTeam.inviteMember('bob')

        // üë®‚Äçü¶≤ Bob accepts the invitation
        const proofOfInvitation = acceptMemberInvitation(secretKey, redactUser(bob))

        // üë®‚Äçü¶≤ Bob shows üë©üèæ Alice his proof of invitation, and she lets him in
        alicesTeam.admitMember(proofOfInvitation)

        // ‚úÖ üë®‚Äçü¶≤ Bob is now on the team. Congratulations, Bob!
        expect(alicesTeam.has('bob')).toBe(true)
      })

      it('lets you use a key of your choosing', () => {
        const { team: alicesTeam } = setup()

        // üë©üèæ Alice invites üë®‚Äçü¶≤ Bob by sending him a secret key of her choosing
        const { secretKey } = alicesTeam.inviteMember('bob', { secretKey: 'passw0rd' })

        // üë®‚Äçü¶≤ Bob accepts the invitation
        const proofOfInvitation = acceptMemberInvitation(secretKey, redactUser(bob))

        // üë®‚Äçü¶≤ Bob shows üë©üèæ Alice his proof of invitation, and she lets him in
        alicesTeam.admitMember(proofOfInvitation)

        // ‚úÖ üë®‚Äçü¶≤ Bob is now on the team. Congratulations, Bob!
        expect(alicesTeam.has('bob')).toBe(true)
      })

      it('normalizes the secret key', () => {
        const { team: alicesTeam } = setup()

        // üë©üèæ Alice invites üë®‚Äçü¶≤ Bob
        alicesTeam.inviteMember('bob', { secretKey: 'abc def ghi' })

        // üë®‚Äçü¶≤ Bob accepts the invitation using a url-friendlier version of the key
        const proofOfInvitation = acceptMemberInvitation('abc+def+ghi', redactUser(bob))
        alicesTeam.admitMember(proofOfInvitation)

        // ‚úÖ Bob is on the team
        expect(alicesTeam.has('bob')).toBe(true)
      })

      it('supports including roles in the invitation', () => {
        const { team: alicesTeam } = setup()

        // üë©üèæ Alice invites üë®‚Äçü¶≤ Bob as admin
        const { secretKey } = alicesTeam.inviteMember('bob', { roles: [ADMIN] })

        // üë®‚Äçü¶≤ Bob accepts the invitation
        const proofOfInvitation = acceptMemberInvitation(secretKey, redactUser(bob))
        alicesTeam.admitMember(proofOfInvitation)

        // ‚úÖ Bob is on the team as an admin
        expect(alicesTeam.memberIsAdmin('bob')).toBe(true)
      })

      it('rejects invitation if name is altered', () => {
        const { team: alicesTeam } = setup()

        // üë©üèæ Alice invites üë®‚Äçü¶≤ Bob
        const { secretKey } = alicesTeam.inviteMember('bob')

        // üë®‚Äçü¶≤ Bob accepts the invitation
        const proofOfInvitation = acceptMemberInvitation(secretKey, redactUser(bob))

        // ü¶π‚Äç‚ôÄÔ∏è Eve intercepts the invitation and tries to use it by swapping out Bob's info for hers
        const forgedProofOfInvitation: ProofOfInvitation = {
          ...proofOfInvitation,
          type: 'MEMBER',
          payload: redactUser(eve),
        }

        // ü¶π‚Äç‚ôÄÔ∏è Eve shows üë©üèæ Alice her fake proof of invitation
        const presentForgedInvitation = () => alicesTeam.admitMember(forgedProofOfInvitation)

        // ‚ùå but üë©üèæ Alice is not fooled
        expect(presentForgedInvitation).toThrow(/User names don't match/)
      })

      it('allows non-admins to accept an invitation', () => {
        let { team: alicesTeam } = setup()
        alicesTeam.add(bob)

        // üë©üèæ Alice invites üë≥‚Äç‚ôÇÔ∏è Charlie by sending him a secret key
        const { secretKey } = alicesTeam.inviteMember('charlie')

        // üë≥‚Äç‚ôÇÔ∏è Charlie accepts the invitation
        const proofOfInvitation = acceptMemberInvitation(secretKey, redactUser(charlie))

        // later, üë©üèæ Alice is no longer around, but üë®‚Äçü¶≤ Bob is online
        let persistedTeam = alicesTeam.save()
        const bobsTeam = load(persistedTeam, bobsContext)

        // just to confirm: üë®‚Äçü¶≤ Bob isn't an admin
        expect(bobsTeam.memberIsAdmin('bob')).toBe(false)

        // üë≥‚Äç‚ôÇÔ∏è Charlie shows üë®‚Äçü¶≤ Bob his proof of invitation
        bobsTeam.admitMember(proofOfInvitation)

        // üë≥‚Äç‚ôÇÔ∏è Charlie is now on the team
        expect(bobsTeam.has('charlie')).toBe(true)

        // ‚úÖ üë©üèæ Alice can now see that üë≥‚Äç‚ôÇÔ∏è Charlie is on the team. Congratulations, Charlie!
        persistedTeam = bobsTeam.save()
        alicesTeam = load(persistedTeam, alicesContext)
        expect(alicesTeam.has('charlie')).toBe(true)
      })

      it('allows revoking an invitation', () => {
        let { team: alicesTeam } = setup()
        alicesTeam.add(bob) // bob is not an admin

        // üë©üèæ Alice invites üë≥‚Äç‚ôÇÔ∏è Charlie by sending him a secret key
        const { secretKey, id } = alicesTeam.inviteMember('charlie')

        // üë≥‚Äç‚ôÇÔ∏è Charlie accepts the invitation
        const proofOfInvitation = acceptMemberInvitation(secretKey, redactUser(charlie))

        // üë©üèæ Alice changes her mind and revokes the invitation
        alicesTeam.revokeInvitation(id)

        // later, üë©üèæ Alice is no longer around, but üë®‚Äçü¶≤ Bob is online
        const persistedTeam = alicesTeam.save()
        const bobsTeam = load(persistedTeam, bobsContext)

        // üë≥‚Äç‚ôÇÔ∏è Charlie shows üë®‚Äçü¶≤ Bob his proof of invitation
        const tryToAdmitCharlie = () => bobsTeam.admitMember(proofOfInvitation)

        // ‚ùå But the invitation is rejected
        expect(tryToAdmitCharlie).toThrowError(/revoked/)

        // üë≥‚Äç‚ôÇÔ∏è Charlie is not on the team
        expect(bobsTeam.has('charlie')).toBe(false)
      })
    })

    describe('devices', () => {
      it('creates and accepts an invitation for a device', () => {
        const { team, context } = setup()
        team.add(bob) // added for code coverage purposes

        // üíª Alice is on her laptop
        expect(context.user.device.name).toBe(`alice's device`)

        // üíª Alice generates an invitation, which is stored on the team's signature chain
        const device = { userName: 'alice', name: `alice's phone`, type: DeviceType.mobile }
        const { secretKey } = team.inviteDevice(device)

        // üì± Alice gets the secret invitation key to her phone, perhaps by typing it in or by scanning a
        // QR code. Alice's phone uses the secret key to generate proof of invitation
        const deviceId = getDeviceId(device)
        const deviceKeys = keyset.create({ type: DEVICE, name: deviceId })
        const deviceWithSecrets: DeviceWithSecrets = { ...device, keys: deviceKeys }
        const proofOfInvitation = acceptDeviceInvitation(secretKey, redactDevice(deviceWithSecrets))

        // üì± Alice's phone connects with üíª her laptop and presents the proof
        team.admitDevice(proofOfInvitation)

        // ‚úÖ üì± Alice's phone is now listed on the signature chain
        expect(team.members('alice').devices!.map(d => d.deviceId)).toContain(deviceId)
      })

      it('rejects device invitation if altered', () => {
        const { team, context } = setup()
        team.add(bob) // added for code coverage purposes

        // üë©üèæüíª Alice is on her laptop
        expect(context.user.device.name).toBe(`alice's device`)

        // üë©üèæüíª Alice generates an invitation, which is stored on the team's signature chain
        const device = { userName: 'alice', name: `alice's phone`, type: DeviceType.mobile }
        const { secretKey } = team.inviteDevice(device)

        // üë©üèæüì± Alice gets the secret invitation key to her phone, perhaps by typing it in or by scanning a
        // QR code. Alice's phone uses the secret key to generate proof of invitation
        const deviceId = getDeviceId(device)
        const deviceKeys = keyset.create({ type: DEVICE, name: deviceId })
        const deviceWithSecrets: DeviceWithSecrets = { ...device, keys: deviceKeys }
        const proofOfInvitation = acceptDeviceInvitation(secretKey, redactDevice(deviceWithSecrets))

        // ü¶π‚Äç‚ôÄÔ∏è Oh no!! Eve intercepts the invitation and tries to use it by swapping out Alice's device info for hers
        const evesDevice = { userName: 'alice', name: `alice's phone`, type: DeviceType.mobile }
        const evesDeviceId = getDeviceId(evesDevice)
        const evesDeviceKeys = keyset.create({ type: DEVICE, name: evesDeviceId })
        const evesDeviceWithSecrets: DeviceWithSecrets = { ...device, keys: evesDeviceKeys }

        const forgedProofOfInvitation: ProofOfInvitation = {
          ...proofOfInvitation,
          type: 'DEVICE',
          payload: redactDevice(evesDeviceWithSecrets),
        }

        // ü¶π‚Äç‚ôÄÔ∏èüì± Eve tries to gain admission with her fraudulent credentials
        const tryToAdmitEve = () => team.admitDevice(forgedProofOfInvitation)

        // ‚ùå Eve's device is not added
        expect(tryToAdmitEve).toThrow(/Signature provided is not valid/)
        const aliceDevices = team.members('alice').devices || []
        expect(aliceDevices.map(d => d.deviceId)).not.toContain(evesDeviceId)
      })
    })
  })
})
